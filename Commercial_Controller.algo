***************************************
-------------COMMERCIAL----------------
***************************************
SET total_floor TO 60
SET total_basement TO 6
SET number_columns_per_battery TO 4
SET num_elev_per_columns TO 3
SET total_stories TO total_floor PLUS total_basement

DEFINE Floors 

    user_list: SET TO EMPTY list
    SEQUENCE create_user_list USING total_stories

        SET story TO 1
        FOR total_stories
            INIT user_request {
                IF story IS EQUAL TO total_basement PLUS 1
                    INIT panel {
                        SET iteration TO 1
                        FOR total_stories
                            IF iteration IS EQUAL TO total_basement PLUS 1 THEN
                                SET btn_floor TO Ground_Floor AND DISABLED

                            ELSE IF iteration IS GREATER THAN total_basement THEN
                                SET btn_floor TO iteration
                                SET user_direction TO UP
                                SET user_stop TO iteration

                            ELSE IF iteration IS SMALLER OR EQUAL TO total_basement THEN
                                SET btn_basement TO iteration
                                SET user_direction TO DOWN
                                SET user_stop TO iteration
                            
                            ENDIF

                            INCREMENT iteration WITH 1
                        ENDFOR
                    }
                    SET user_position TO story

                ELSE IF story IS GREATER THAN total_basement PLUS 1 THEN
                    SET btn_ground_floor TO "GF"
                    SET user_direction TO DOWN
                    SET user_stop TO total_basement PLUS 1
                    SET user_position TO story

                ELSE IF story IS SMALLER OR EQUAL TO total_basement THEN
                    SET btn_ground_floor TO "GF"
                    SET user_direction TO UP
                    SET user_stop TO total_basement PLUS 1
                    SET user_position TO story

                ENDIF
            }
            INCREMENT story WITH 1
        ENDFOR
    ENDSEQUENCE

    WHEN btn_floor is PRESS
        CALL 

    WHEN btn_ground_floor PRESS
        CALL call_ground WITH user_request
            
ENDDEFINE

DEFINE Battery

    columns_list: SET TO EMPTY list
    SEQUENCE create_culumns_list USING number_columns_per_battery
        SET iteration TO 0
        SET floor_per_column TO total_floor DIVIDED BY (SUBSTRACT 1 FROM number_columns_per_battery)

        FOR number_columns_per_battery
            ADD column {
                SET status TO AVCTIVE
                init max_range
                init min_range
                
                SEQUENCE
                    IF iteration IS EQUAL TO 0 THEN
                        SET max_range TO total_basement
                        SET min_range TO 1

                    ELSE
                        SET max_range TO iteration MULTIPLY BY floor_per_column
                        SET min_range TO max_range OF PREVIOUS index OF column PLUS 1

                    ENDIF
                ENDSEQUENCE

                elevators_list: SET TO EMPTY list
                SEQUENCE create_elevators_list USING num_elev_per_columns
                    FOR num_elev_per_columns
                        ADD elevator {
                            init points
                            init stop_list
                            init UP_buffer_list
                            init DOWN_buffer_list
                            init elevator_direction
                            SET elevator_floor TO 1
                            SET elevator_door TO CLOSE
                            SET status TO IDLE
                        } TO elevators_list
                    ENDFOR
                ENDSEQUENCE
            } TO columns_list

            INCREMENT iteration WITH 1
        ENDFOR
    ENDSEQUENCE
ENDDEFINE

SEQUENCE selection USING user_request

    IF user_stop IS EQUAL TO total_basement PLUS 1 THEN
        FOR EACH column IN Battery
            IF user_position IS GREATER OR EQUAL TO min_range AND user_position IS SMALLER OR EQUAL TO max_range THEN
                CALL request_check WITH user_request and column
            ENDIF
        ENDFOR

    ELSE 
        FOR EACH column IN Battery 
            IF user_stop IS GREATER OR EQUAL TO min_range AND user_stop IS SMALLER OR EQUAL TO max_range THEN
                CALL request_check WITH user_request and column
            ENDIF
        ENDFOR

    ENDIF

ENDSEQUENCE

-------------------------------------------------------------------------------------------------------------------------------pointing system
SEQUENCE request_check USING user_request and column

    FOR EACH elevator IN column
        IF elevator_door IS OPEN THEN
            WAIT FOR elevator_door TO CLOSE THEN
                IF user_position IS EQUAL TO total_basement PLUS 1 THEN
                    CALL points_update_lobby WITH user_request and elevator

                ELSE
                    CALL points_update_floor WITH user_request and elevator

                ENDIF

        ELSE IF elevator_door IS CLOSE THEN
            IF user_position IS EQUAL TO total_basement PLUS 1 THEN
                CALL points_update_lobby WITH user_request and elevator

            ELSE
                CALL points_update_floor WITH user_request and elevator

            ENDIF
        ENDIF
    ENDFOR

    CALL elevator_send WITH user_request and column

ENDSEQUENCE

SEQUENCE points_update_floor USING user_request and elevator

    IF status IS NOT IDLE THEN 
        SET differance_last_stop TO POSITIVE NUMBER OF THE DIFFERANCE BETWEEN LAST INDEX OF stop_list and user_position
    ENDIF

    SET differance_floor TO POSITIVE NUMBER OF THE DIFFERANCE BETWEEN elevator_floor and user_position
    SET max_differance_floor TO max_range 
    SET points TO 0

    IF elevator_direction IS EQUAL TO user_direction AND status IS NOT IDLE AND  THEN
        SET points TO differance_last_stop

    ELSE IF status IS IDLE THEN
        SET points TO max_range PLUS 1
        INCREMENT points WITH differance_floor

    ELSE IF elevator_direction IS NOT EQUAL TO user_direction AND status IS NOT IDLE THEN
        SET points TO max_range MULTIPLY BY 2
        INCREMENT points WITH LENGTH OF stop_list
        INCREMENT points WITH differance_last_stop

    ENDIF

ENDSEQUENCE

SEQUENCE points_update_lobby USING user_request and elevator

    IF status IS NOT IDLE THEN 
        SET differance_last_stop TO POSITIVE NUMBER OF THE DIFFERANCE BETWEEN LAST INDEX OF stop_list and user_position
    ENDIF

    SET differance_floor TO POSITIVE NUMBER OF THE DIFFERANCE BETWEEN elevator_floor and user_position
    SET max_differance_floor TO max_range 
    SET points TO 0

    IF elevator_direction IS NOT EQUAL TO user_direction AND status IS NOT IDLE THEN
        SET points TO differance_last_stop 

    ELSE IF status IS IDLE THEN
        SET points TO max_range PLUS 1
        INCREMENT points WITH differance_floor

    ELSE IF elevator_direction IS EQUAL TO user_direction AND status IS NOT IDLE THEN
        SET points TO max_range MULTIPLY BY 2
        INCREMENT points WITH LENGTH OF stop_list
        INCREMENT points WITH differance_last_stop

    ENDIF

ENDSEQUENCE
-------------------------------------------------------------------------------------------------------------------------------/pointing system

-------------------------------------------------------------------------------------------------------------------------------elevator choice based on points
SEQUENCE elevator_send USING user_request and column

    SORT elevator_list OF column IN INCREASING ORDER OF points

    SET best_elevator TO the FIRST INDEX OF elevator_list IN column

    DISPLAY column and best_elevator ON panel

    CALL add_stop WITH best_elevator and user_request

ENDSEQUENCE
-------------------------------------------------------------------------------------------------------------------------------/elevator choice based on points

-------------------------------------------------------------------------------------------------------------------------------all stop related function
SEQUENCE list_sort USING elevator

    IF elevator_direction IS UP THEN
        SORT IN INCREASING ORDER WITH stop_list

    ELSE IF elevator_direction IS DOWN THEN
        SORT IN DECREASING ORDER WITH stop_list

    ENDIF

ENDSEQUENCE

SEQUENCE add_stop USING elevator and user_request

    IF user_position IS EQUAL TO total_basement PLUS 1 THEN
        IF user_direction IS NOT EQUAL TO elevator_direction AND user_position IS SMALLER TO elevator_floor THEN
            ADD user_position TO stop_list
            ADD user_stop TO UP_buffer_list

        ELSE IF user_direction IS NOT EQUAL TO elevator_direction AND user_position IS GREATER TO elevator_foor THEN
            ADD user_position TO stop_list
            ADD user_stop TO DOWN_buffer_list
        
        ELSE IF status IS IDLE THEN
            ADD user_position TO stop_list
            IF user_direction IS DOWN THEN
                ADD user_stop TO DOWN_buffer_list
            
            ELSE IF user_direction IS UP THEN
                ADD user_stop TO UP_buffer_list

            ENDIF

        ELSE IF user_direction IS EQUAL TO elevator_direction AND user_position IS SMALLER OR EQUAL THAN elevator_floor THEN
            ADD user_position TO DOWN_buffer_list
            ADD user_stop TO UP_buffer_list

        ELSE IF user_direction IS EQUAL TO elevator_direction AND user_direction IS GREATER OR EQUAL THAN elevator_floor THEN
            ADD user_position TO UP_buffer_list
            ADD user_stop TO DOWN_buffer_list

        ENDIF

    ELSE
        IF status IS IDLE THEN
            ADD user_position TO stop_list
            IF user_direction IS UP THEN
                ADD user_stop TO UP_buffer_list
            
            ELSE IF user_direction IS DOWN THEN
                ADD user_stop TO DOWN_buffer_list
        
            ENDIF

        ELSE IF user_direction IS EQUAL TO elevator_direction AND user_position IS SMALLER OR EQUAL THAN elevator_foor THEN
            ADD user_position TO stop_list
            ADD user_stop TO stop_list
        
        ELSE IF user_direction IS EQUAL TO elevator_direction AND user_position IS GREATER OR EQUAL THAN elevator_floor THEN
            ADD user_position TO stop_list
            ADD user_stop TO stop_list

        ELSE IF user_direction IS NOT EQUAL TO elevator_direction AND user_direction IS UP THEN
            ADD user_position TO UP_buffer_list
            ADD user_stop TO UP_buffer_list

        ELSE IF user_direction IS NOT EQUAL TO elevator_direction AND user_direction IS DOWN THEN
            ADD user_position TO DOWN_buffer_list
            ADD user_stop TO DOWN_buffer_list

        ENDIF
    ENDIF

    CALL list_sort WITH elevator

ENDSEQUENCE
-------------------------------------------------------------------------------------------------------------------------------

-------------------------------------------------------------------------------------------------------------------------------
SEQUENCE stop_switch USING elevator

    IF LENGTH OF DOWN_buffer_list IS < THAN LENGTH OF UP_buffer_list THEN
        ADD UP_buffer_list TO stop_list

    ELSE IF LENGTH OF DOWN_buffer_list IS > THAN LENGTH OF UP_buffer_list THEN
        ADD DOWN_buffer_list TO stop_list

    ELSE IF LENGTH OF DOWN_buffer_list IS EQUAL TO LENGTH OF UP_buffer_list THEN
        ADD random buffer_list TO stop_list

    ELSE IF UP_buffer_list IS EMPTY AND DOWN_buffer_list IS EMPTY THEN
        SET status TO IDLE
        SET elevator_direction TO STOP

    ENDIF

ENDSEQUENCE
-------------------------------------------------------------------------------------------------------------------------------/all stop related function

    "IF user_direction IS EQUAL TO elevator_direction AND user_position IS EQUAL TO elevator_floor THEN
        SET points TO NEGATIVE 1

    ELSE IF user_direction IS EQUAL TO elevator_direction AND user_position IS GREATER THAN elevator_floor THEN
        SET points TO 0
        CALL pointing WITH user_request and elevator

    ELSE IF user_direction IS EQUAL TO elevator_direction AND user_position IS SMALLER THAN elevator_floor THEN
        SET points TO 0
        CALL pointing WITH user_request and elevator

    ELSE IF user_direction IS NOT EQUAL TO elevator_direction AND status IS NOT IDLE THEN
        SET points TO total_stories PLUS 1

    ENDIF"

SEQUENCE pointing USING user_request and elevator

    SET value TO POSITIVE NUMBER OF THE DIFFERANCE BETWEEN elevator_floor and user_position

    CASE (value) OF
        FOR min_range TO max_range IN THE column
            IF range IS EQUAL TO value
                INCREMENT points IN elevator WITH value PLUS 1
            ENDIF
        ENDFOR
    ENDCASE

ENDSEQUENCE
